<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://ohlulu.github.io/</id><title>Ohlulu</title><subtitle>ohlulu, iOS, Swift</subtitle> <updated>2022-06-24T15:15:50+08:00</updated> <author> <name>ohlulu</name> <uri>https://ohlulu.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://ohlulu.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-TW" href="https://ohlulu.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 ohlulu </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>當 Decodable 遇上 @propertyWrapper</title><link href="https://ohlulu.github.io/posts/decodable_propertywrapper/" rel="alternate" type="text/html" title="當 Decodable 遇上 @propertyWrapper" /><published>2020-07-18T00:00:00+08:00</published> <updated>2020-07-18T00:00:00+08:00</updated> <id>https://ohlulu.github.io/posts/decodable_propertywrapper/</id> <content src="https://ohlulu.github.io/posts/decodable_propertywrapper/" /> <author> <name>ohlulu</name> </author> <category term="tip" /> <summary> 在 Swift 5.1 之後，蘋果爸爸推出了 @propertyWrapper ( SE-0258 )，屬性包裝器，詳細的使用及說明，這邊就不多做介紹了。剛開始的時候最常看到的應用是 Userdefaults，我自己在專案中應用的部分則是 Begin/End of date，因為有選擇日期區間的需求，所以做了一個這樣的屬性，在 init 的時候指定好是 Begin or End，get 的時候就會先整理一次日期，詳細的實作我放在 Gist 有興趣的同學可以參考看看。 # 情境 當我待在 Agency 的時候經常遇到一個問題，後端的 API 沒有照 Spec 做，尤其是型別的問題，我想這應該很多人都有遇過，Spec 明明定義的是 Int，後端傳卻是 String。或是因為某些不明的原因，後端漏傳了某個欄位，但實際上這個欄位是必須存在的。甚至是後端 key 打錯了。更淒慘的是，如果是... </summary> </entry> <entry><title>CoderEngin-漂亮的方式取用圖片</title><link href="https://ohlulu.github.io/posts/coderengin/" rel="alternate" type="text/html" title="CoderEngin-漂亮的方式取用圖片" /><published>2020-04-19T00:00:00+08:00</published> <updated>2020-04-19T00:00:00+08:00</updated> <id>https://ohlulu.github.io/posts/coderengin/</id> <content src="https://ohlulu.github.io/posts/coderengin/" /> <author> <name>ohlulu</name> </author> <category term="technology" /> <summary> #起 在 iOS 開發的過程中，取用圖片的時候我們經常使用 UIImage(named: "add") 這樣的方式，使用圖片檔名+字串的方式，雖然現在多數的設計師會使用 zeplin 等工具方便工程師複製檔名，但使用字串總是不那麼漂亮。 而且每次使用都區要先把視窗切到 zeplin 在切回來。個人使用起來總感覺不是那麼流暢。 #承 因此，在之後的專案中，想到使用 UIImage static compute property 的方式來取用圖片，字串的部分只要寫一次就好。 extension UIImage { static var save: UIImage { return UIImage(named: "save")! } } // 使用起來會像這樣 let imageView = UIImageView(image: .save) ... </summary> </entry> <entry><title>Alamofire - APIRouter</title><link href="https://ohlulu.github.io/posts/alamofire-apirouter/" rel="alternate" type="text/html" title="Alamofire - APIRouter" /><published>2019-09-20T00:00:00+08:00</published> <updated>2019-09-20T00:00:00+08:00</updated> <id>https://ohlulu.github.io/posts/alamofire-apirouter/</id> <content src="https://ohlulu.github.io/posts/alamofire-apirouter/" /> <author> <name>ohlulu</name> </author> <category term="technology" /> <summary> Alamofire - APIRouter 2020/6 更新 在 iPlayground2019 聽完王巍大大的 talk 之後，又自己實作了三次，已經放棄下面的封裝方式 範例在 Github，因為實作概念基本上等同王巍大大的 Talk（多了一些參考自 Moya 的概念）所以等 哪天心情好 有空，再來寫一篇文章好了哈哈哈哈哈。 # 起 Alamofire 相信開發 iOS 的人都不陌生，就算沒用過也聽，非常好用的一個第三方網路處理套件，網路上也有非常多關於 Alamofire 的封裝，google alamofire router 的教學文章也是一大堆。 大部分的文章看起來都會像這樣： enum APIRouter { case fetchData case uploadData case deleteData(String) var ... </summary> </entry> <entry><title>心路歷程-打造一個優雅的初始化框架</title><link href="https://ohlulu.github.io/posts/ohswifterframework/" rel="alternate" type="text/html" title="心路歷程-打造一個優雅的初始化框架" /><published>2019-08-13T00:00:00+08:00</published> <updated>2022-05-25T23:49:44+08:00</updated> <id>https://ohlulu.github.io/posts/ohswifterframework/</id> <content src="https://ohlulu.github.io/posts/ohswifterframework/" /> <author> <name>ohlulu</name> </author> <category term="tip" /> <summary> 最近因為手上的案子告一段落，距離下一個案子進入開發階段也還有一點時間，所以興起了整理自己常用的 extension 的想法。 以目前待在接案公司來說，重要的就是畫面的快速產出，邏輯的部分相對產品來說，其實沒有那麼複雜。 所以在畫面瘋狂的建立&amp;amp;設置的情況下，一個方便好用的設置方式，其實滿重要的。在重複建立相似但卻不一樣的 UI 時，也會相對的輕鬆，且愉悅。 所以這篇會簡述一下，我從 學習 -&amp;gt; 工作 -&amp;gt; 產出一個框架的心路歷程。 待在一間接案公司，快速、有效率的產出，是一件非常重要的事。 # 蹣跚學步 在初學 Swift 的時候，我總是在檔案的上方宣告UIKit類的元件，並在 ViewDidLoad中作原件樣式的設定，看起來會是這樣👇。 let emailLabel = UILabel() override func viewDidLoad... </summary> </entry> <entry><title>Swift 自訂轉場動畫，手勢(下)</title><link href="https://ohlulu.github.io/posts/swift-custom_transition_animation_2/" rel="alternate" type="text/html" title="Swift 自訂轉場動畫，手勢(下)" /><published>2019-03-31T00:00:00+08:00</published> <updated>2019-03-31T00:00:00+08:00</updated> <id>https://ohlulu.github.io/posts/swift-custom_transition_animation_2/</id> <content src="https://ohlulu.github.io/posts/swift-custom_transition_animation_2/" /> <author> <name>ohlulu</name> </author> <category term="animation" /> <summary> Demo GIF 這篇主要講手勢的使用，關於動畫實作的部分，在 上篇 有詳細的code 接下來要在我們建立的 CustomTransition 裡面，跟系統說：我們的互動事件要透過誰來管理互動。 class CustomTransition: NSObject, UIViewControllerTransitioningDelegate { // ... let interaction = UpToDownIneraction() func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -&amp;gt; UIViewControllerInteractiveTransitioning? { re... </summary> </entry> </feed>
