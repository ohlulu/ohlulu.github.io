[ { "title": "當 Decodable 遇上 @propertyWrapper", "url": "/posts/decodable_propertywrapper/", "categories": "tip", "tags": "", "date": "2020-07-18 00:00:00 +0800", "snippet": "在 Swift 5.1 之後，蘋果爸爸推出了 @propertyWrapper ( SE-0258 )，屬性包裝器，詳細的使用及說明，這邊就不多做介紹了。剛開始的時候最常看到的應用是 Userdefaults，我自己在專案中應用的部分則是 Begin/End of date，因為有選擇日期區間的需求，所以做了一個這樣的屬性，在 init 的時候指定好是 Begin or End，get 的時候就會先整理一次日期，詳細的實作我放在 Gist 有興趣的同學可以參考看看。# 情境當我待在 Agency 的時候經常遇到一個問題，後端的 API 沒有照 Spec 做，尤其是型別的問題，我想這應該很多人都有遇過，Spec 明明定義的是 Int，後端傳卻是 String。或是因為某些不明的原因，後端漏傳了某個欄位，但實際上這個欄位是必須存在的。甚至是後端 key 打錯了。更淒慘的是，如果是 Array 中某個值錯了，整大包就會解析失敗。在以前，我們有幾個方式可以解決這些問問題： 自己定義一個型別： 可能像是 StringOrInt 這種，並實作 Decodable。但這只能解決 String ↔ Int，這種錯誤。 Decode 失敗就失敗：但每次失敗我都會將 DecodingError 直接用 Alert show 在畫面上，所以只要有人測到 DecoginError 相關的問題，就可以直接螢幕截圖並傳給我，我可以比較經鬆的定位失敗的 API，並通知後端修正。（當然這種作法必須限定在開發環境） 把所有的變數都宣告成 Optional：但這只能解決 KeyNotFound，而且後續的開發上需要處理一堆 Optional。 自己實作 init(from decoder: Decoder) ：但我不可能、也不想為每個 response model 實做這個 func，費時又費力，很不工程師。# 還是有一些問題上面的解法在某種程度上分別解決了 DecodingError 的問題，但依然有一些問題： 解決方法沒有統一的介面。（醜） 某些方法實作不易。（麻煩） 某些方法出錯的時候定位不容易，因為本質上是 Bug ，是需要被解決的。 後端的鍋為毛是我們扛？為毛是我們要找出問題在哪，再請後端改？（😠 ）# DecodeStrategyOf course, DecodeStrategy 誕生了。最初的想法是想用「一個 @propertyWrapper」來解決所有問題，但嘗試到一半發現真的做不到 ( 或許是我太菜了QQ )，加上之前學到的教訓 「不要試圖在一行 code 裡面包山包海」。我決定針對各個狀況各自使用一個 @propertyWrapper。讓我們一個一個來看： 首先是預設值的部分：在某些情況之下，我希望解析失敗的時候，Model 可以有預設值。 最早的想法是，在 propertyWrapper init 的時候，順便指定預設值是什麼。 @DecodeHasDefault(&quot;Something error&quot;) 但這樣的做法會跟 init(from decoder: Decoder) 衝突，所以後來改用 Provider 的方式來提供預設值。 public protocol DecodeDefaultProvider { associatedtype Value: Decodable static var defaultValue: Value { get } } @propertyWrapper public struct DecodeHasDefault: Decodable { public var wrappedValue: Provider.Value public init(wrappedValue: Provider.Value) { self.wrappedValue = wrappedValue } public init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() do { wrappedValue = try container.decode(Provider.Value.self) } catch { wrappedValue = Provider.defaultValue } } } 使用起來會像是這樣 struct User: Decodable { struct NameDefault: DecodeDefaultProvider { static var defaultValue: String = &quot;ohlulu&quot; } @DecodeHasDefault var name: String struct AgeDefault: DecodeDefaultProvider { static var defaultValue: Int = 18 } @DecodeHasDefault var age: Int } 這部分比較單純，就是提供一個 DecodeDefaultProvider，讓 DecodeHasDefault 在 catch error 的時候使用 defaultValue 再來是 DecodeArray 的部分。 這邊有兩種情況：一種是解析失敗的時候，直接忽略該 Element。另一種是使用預設的 Element。 第一種：DecodeArrayIgnore @propertyWrapper public struct DecodeArrayIgnore: Decodable { public var wrappedValue: [Value] public init(from decoder: Decoder) throws { var container = try decoder.unkeyedContainer() var result = [Value]() while !container.isAtEnd { do { let element = try container.decode(Value.self) result.append(element) } catch { _ = try container.decode(AnyDecodable.self) } } wrappedValue = result } } 這邊需要注意，catch error 的時候還是要 decode 成功一次，不然 element 不會從 container 中移除，會陷入一個無窮迴圈，所以用一個空的 struct AnyDecodable 來做這件事，如果還是失敗了，就 throw 出去吧。 第二種：DecodeArrayHasDefault @propertyWrapper public struct DecodeArrayHasDefault: Decodable { public var wrappedValue: [Provider.Value] public init(from decoder: Decoder) throws { var container = try decoder.unkeyedContainer() var result = [Provider.Value]() while !container.isAtEnd { do { let element = try container.decode(Provider.Value.self) result.append(element) } catch { _ = try container.decode(AnyDecodable.self) result.append(Provider.defaultValue) } } wrappedValue = result } } 跟上面很像，只是 Generic 的部分改成了 DecodeDefaultProvider，這邊會選擇拆成理個 @propertyWrapper 是因為 ignore 不需要 Provider ，當然 Provider 也可以提供一個類似 Optional 的 enum 來達成通用的目的，但考慮到需求是 ignore 的時候，我希望使用上可以更單純一點，不用再指定 Provider。 所以最終選擇拆成兩個。 最後一種最麻煩：DecodeUniversal 直接上 Code public typealias LosslessAndDecodable = LosslessStringConvertible &amp;amp; Decodable @propertyWrapper public struct DecodeUniversal: Decodable { public var wrappedValue: Value public init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() do { wrappedValue = try container.decode(Value.self) } catch { let temp: String if let strValue = try? container.decode(String.self) { temp = strValue } else if let intValue = try? container.decode(Int.self) { temp = &quot;\\(intValue)&quot; } else if let doubleValue = try? container.decode(Double.self) { temp = &quot;\\(doubleValue)&quot; } else { throw error } if let value = Value.init(temp) { wrappedValue = value } else { throw error } } } } 這邊有一個比較少看到的 protocol LosslessStringConvertible，詳細的定義可以參考 Document，簡單來說它提供了我們用字串建立 Int, Double 等類型的能力。 所以我們先 decode(Value.self) 一次看看，失敗的話，我們從 String -&amp;gt; Int -&amp;gt; Double 依次 decode，只要 decode 成功，就把值轉成 String 存起來。如果依然 decode 失敗，勇敢的 throw 出去吧！ 接著利用 LosslessStringConvertible 提供的 init?(_ description: String) 來嘗試建立物件，如果還是失敗，勇敢的 throw 出去吧！ 到這邊就完成啦 😄 # 讓我們回頭看看✅ 1. 解決方法沒有統一的介面。✅ 2. 某些方法實作不易。❌ 2. 某些方法出錯的時候定位不容易，因為本質上是 Bug ，是需要被解決的。❌ 3. 後端的鍋為毛是我們扛？為毛是我們要找出問題在哪，再請後端改？忙了老半天，我們只解決了一半的問題？別緊張，還有後續。# 讓錯誤出現時有一個 Handler我們先宣告一個 protocol DecodeErrorDelegate，並宣告 DecodeStrategy 裡面有一個 static var 是 DecodeErrorDelegate。public protocol DecodeErrorDelegate { func onCatch(error: Error)}public struct DecodeStrategy { public static var errorDelegate: DecodeErrorDelegate?}接著我們在 catch error 的時候，把 error 透過 DecodeStrategy.errorDelegate?.onCatch(error:) 傳出去。do { wrappedValue = try container.decode(Provider.Value.self)} catch { DecodeStrategy.errorDelegate?.onCatch(error: error) wrappedValue = Provider.defaultValue}完美，這樣我們就可以在使用的時候有一個統一的接口可以做事了。你可以在自己的 DecodeErrorDelegate 設置 flag ，標注現在準備 deocde 哪個 response model，並在 onCatch 的時候印出來，或者請後端直接再開一隻接收 JSON Bug 的 API，每次 onCatch 都呼叫 API 通知後端修正。想怎麼玩就怎麼玩。完整的專案在 Github。如果你覺得不錯的話，歡迎給個 Star 支持一下 😄" }, { "title": "CoderEngin-漂亮的方式取用圖片", "url": "/posts/coderengin/", "categories": "technology", "tags": "python, swift, xcode, script, automation", "date": "2020-04-19 00:00:00 +0800", "snippet": "#起在 iOS 開發的過程中，取用圖片的時候我們經常使用 UIImage(named: &quot;add&quot;) 這樣的方式，使用圖片檔名+字串的方式，雖然現在多數的設計師會使用 zeplin 等工具方便工程師複製檔名，但使用字串總是不那麼漂亮。而且每次使用都區要先把視窗切到 zeplin 在切回來。個人使用起來總感覺不是那麼流暢。#承因此，在之後的專案中，想到使用 UIImage static compute property 的方式來取用圖片，字串的部分只要寫一次就好。extension UIImage { static var save: UIImage { return UIImage(named: &quot;save&quot;)! }}// 使用起來會像這樣let imageView = UIImageView(image: .save)當然開源套件 R.swfit 也可以達到這樣的效果，不過 R.swift 是另外宣告一個自己的型別，所以 Swift 的型別推斷沒辦法直接使用 .save 的方式來取用圖片。必須 R.image.safe() 像這樣使用，感覺上稍微冗長了一點。#轉由於專案中的圖片數量可能不止十幾張、幾十張，可能是上百張，如果每個圖片都要自己打一次，容易出錯不說，新增修改刪除圖片的時候不好維護，由於這個動作相對單純，於是想到使用腳本的方式來幫我們解決。所以有兩個問題需要解決 手動產生這個檔案很麻煩寫容易出錯 增修改刪除圖片的時候不好維護剛好想玩一下 python，就決定使用 python 來完成這件事啦。初代的腳本 用起來大概像是這樣 CoderEngine 那時候是請設計師，將專案所有的圖片打包一份給我，直接 parse 這份檔案，這個做法解決了 問題1 ，但 問題2 依然存在。不過還算堪用，所以也將就的先用在專案上了。#合後來 KuoChingHao 大大，聽到我寫了一個這樣的腳本之後，說也想玩一下腳本，我們兩合計了一下，由 KuoChingHao 大大操刀，做出了以下修改。 直接 parse Assets.xcasset 將檔名的底線改為駝峰（add_pressed -&amp;gt; addPressed） 去掉檔名中的 dash（add-1 -&amp;gt; add1） 在專案中使用 build pre-action script我後續更新了 deep parse ，解決了 Assets 中存在資料夾的情況。使用起來會像是這樣原始碼在 Github" }, { "title": "Alamofire - APIRouter", "url": "/posts/alamofire-apirouter/", "categories": "technology", "tags": "alamofire, tip", "date": "2019-09-20 00:00:00 +0800", "snippet": "Alamofire - APIRouter2020/6 更新在 iPlayground2019 聽完王巍大大的 talk 之後，又自己實作了三次，已經放棄下面的封裝方式 範例在 Github，因為實作概念基本上等同王巍大大的 Talk（多了一些參考自 Moya 的概念）所以等 哪天心情好 有空，再來寫一篇文章好了哈哈哈哈哈。# 起Alamofire 相信開發 iOS 的人都不陌生，就算沒用過也聽，非常好用的一個第三方網路處理套件，網路上也有非常多關於 Alamofire 的封裝，google alamofire router 的教學文章也是一大堆。大部分的文章看起來都會像這樣：enum APIRouter { case fetchData case uploadData case deleteData(String) var method: HTTPMethod { switch self { case .fetchData: return .get case .uploadData: return .post case .deleteData: return .post } } var path: String { switch self { case .fetchData: return &quot;/data/list&quot; case .uploadData: return &quot;/data/uplod&quot; case .deleteData: return &quot;/data/delete&quot; } } var parameters: Parameters? { switch self { case .fetchData: return [&quot;time&quot;: DataLastSyncTime] case .uploadData: return [&quot;data&quot;: Data] case .deleteData(let id): return [&quot;id&quot;: id] } } func asURLRequest() throws -&amp;gt; URLRequest { //... retutn ... }}# 承假設今天我們是的 APP 只有需要呼叫 十幾支 API ，這樣的寫法或許感覺不到什麼問題，但是當 API 的數量增加到 幾十支 的時候，就會發現整個 router 非常的混亂，每次增加一支 API ，就需要把整個檔案重頭滾動到尾，一個 http request 的 URL、http method、 parameters，散落在檔案的各處，不管是新增還是修改都極為麻煩。# 轉後來在網路上發現了一個更好的寫法，但原文找不到了，後來我憑著印象重現了當初看到的文章。struct APIRouter: URLRequestConvertible { let path: String let method: HTTPMethod var parameters: Parameters? func asURLRequest() throws -&amp;gt; URLRequest { let url = URL(string: &quot;https://www.google.com&quot;)! .appendingPathComponent(path) var urlRequest = URLRequest(url: url) urlRequest.httpMethod = method.rawValue urlRequest.timeoutInterval = 30 // Http common header urlRequest.allHTTPHeaderFields = ESHTTPHeaders.default // add custom do { return try JSONEncoding.default.encode(urlRequest, with: parameters) } catch { fatalError(&quot;\\(error)&quot;) } }}extension APIRouter { static func login(requestModel model: LoginRequestModel) -&amp;gt; APIRouter { return APIRouter(path: &quot;/login&quot;, method: .post, parameters: model.convertToParameter()) }}這邊應該是使用了 工廠模式(factory pattern)我把 enum 改成了 struct ，然後一樣 confirm URLRequestConvertible ，並實作 asURLRequest() ，然後使用 static func create 這個 struct。其中最後的 model.convertToParameter() 是自己宣告 &amp;amp; 實作的 protocolprotocol ParameterConvertible { func convertToParameter() -&amp;gt; Parameters?}extension ParameterConvertible where Self: Encodable { func convertToParameter() -&amp;gt; Parameters? { do { let data = try JSONEncoder().encode(self) return try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] } catch { fatalError(&quot;\\(error)&quot;) } }}假設 model 沒有特殊的變化，就可以使用預設的 func convertToParameter() ，如果今天 model 與 api 的參數對應不起來，也可以 model 自己實作這個 func 來客製參數的結構。# 合所以我們把一個 http request 的 URL、http method、 parameters… 的資訊，通通寫在一個 func 了，是不是清楚許多Ｒ。" }, { "title": "心路歷程-打造一個優雅的初始化框架", "url": "/posts/ohswifterframework/", "categories": "tip", "tags": "", "date": "2019-08-13 00:00:00 +0800", "snippet": "最近因為手上的案子告一段落，距離下一個案子進入開發階段也還有一點時間，所以興起了整理自己常用的 extension 的想法。以目前待在接案公司來說，重要的就是畫面的快速產出，邏輯的部分相對產品來說，其實沒有那麼複雜。所以在畫面瘋狂的建立&amp;amp;設置的情況下，一個方便好用的設置方式，其實滿重要的。在重複建立相似但卻不一樣的 UI 時，也會相對的輕鬆，且愉悅。所以這篇會簡述一下，我從 學習 -&amp;gt; 工作 -&amp;gt; 產出一個框架的心路歷程。 待在一間接案公司，快速、有效率的產出，是一件非常重要的事。# 蹣跚學步在初學 Swift 的時候，我總是在檔案的上方宣告UIKit類的元件，並在 ViewDidLoad中作原件樣式的設定，看起來會是這樣👇。let emailLabel = UILabel()override func viewDidLoad() { super.viewDidLoad() emailLabel.text = &quot;z30262226@gmail.com&quot; emailLabel.font = UIFont.systemFont(ofSize: 14, weight: .regular) emailLabel.textColor = .black emailLabel.textAlignment = .center emailLabel.numberOfLines = 0 emailLabel.backgroundColor = .white emailLabel.layer.cornerRadius = 5 view.addSubview(emailLabel) // 然後是 Autolayout ...}如果今天畫面上只有一兩個 UI元件，這樣寫或許不是太大的問題，但實際案子中不太可能有這樣的需求，那在畫面上的東西多起來之後，整個 ViewDidLoad 會變的非常混亂。# 邯鄲學步人總是會進步的，曾經看過這麼一句話，具體怎麼說忘了，但意思大概是。 如果三個月後，看三個月前寫的程式碼，還可以感覺寫得真好，這是一件很恐怖的事。這句話也可以看出工程師們學不完的人生 😂。隨著看過的程式碼、文章、教學、Stack Overflow越來越多，開始有了用 func 包裝程式碼的觀念，於是我把所有關於 UI 的樣式設置、Autolayout 都用一個 func 包起來，並放在整個檔案的最下方。看起來會是下面這樣👇。private let emailLabel = UILabel()override func viewDidLoad() { super.viewDidLoad() setupUI()}// MARK: - SetupUIprivate extension ViewController { func setupUI() { emailLabel.text = &quot;z30262226@gmail.com&quot; emailLabel.font = UIFont.systemFont(ofSize: 14, weight: .regular) emailLabel.textColor = .black emailLabel.textAlignment = .center emailLabel.numberOfLines = 0 emailLabel.backgroundColor = .white emailLabel.layer.cornerRadius = 5 view.addSubview(emailLabel) // 然後是 Autolayout ... }}漸漸的、開始加上權限的宣告、使用 // MARK: - 、以及 extension 來切割程式碼。一瞬間，class 宣告變數的地方，看起來 很乾淨。但很快的，我發現 setupUI 裡面其實問題依舊。 宣告與樣式的設定，被拆成了兩部分。 當大量的 UI 元件被放入的時候，樣式設置+Autolayout 一樣讓程式碼變的雜亂。 結論：我只是把雜亂的程式碼換了一個地方擺而已。# 日積月累接下來的一段時間，其實看了滿多文章，但其中 coding style 的部分通常只有片段的規範。這時候，換了工作，終於有了同樣寫 iOS 的同事😭，發現他的程式碼有許多方便的 func &amp;amp; property 可以呼叫，看了一下原始碼發現多數是來自於 SwifterSwift ，我參考了套件裡面的做法，自己寫自己常用的方法，選擇自己寫的原因是希望自己可以理解的更透徹，並且把這種重用的概念養成一種習慣。同時，對 Swift 的語法也瞭解的更深了。因此產生了下面這種寫法。private let emailLabel: UILabel = { let label = UILabel() label.text = &quot;z30262226@gmail.com&quot; label.font = UIFont.systemFont(ofSize: 14, weight: .regular) label.textColor = .black label.textAlignment = .center label.numberOfLines = 0 label.backgroundColor = .white label.cornerRadius = 5 // 利用 extension 將 layer 的使用省略 return label}()override func viewDidLoad() { super.viewDidLoad() setupUI()}// MARK: - SetupUIprivate extension ViewController { func setupUI() { // emailLabel view.addSubview(emailLabel) // 然後是 Autolayout ... }}這樣的好處是，我把宣告與樣式的設置，寫在一起了。因為佈局的部分，有時候會一層疊一層，因此我選擇另外包成一塊，並放在最下面，補充一下放在最下面的原因是：通常佈局的部分寫好之後，就不太需要去動到的，會修改的部分通常是邏輯。這樣的寫法維持了好長一段時間，但久了問題也漸漸浮出來了。 首先是 init closure 裡面 label 重複輸入的很多次。 再來是 emailLabel 後面必須宣告型別，即便 closure 回傳了 UILabel 的物件。就算宣告了型別，內部的 let label = UILabel() &amp;amp; return label 看起來也顯得有點多餘。 算上 init &amp;amp; return &amp;amp; closure尾部的() 總共多了三行個人認為沒什麼意義的 code 字型與文字顏色的部分，基本上是每個 UILabel &amp;amp; UIButton 都需要設置的屬性，每次初使用的時候都要重新打一次；我覺得不行。 # 異想天開—曾經走錯的那段路。這是一個我自己創造，卻在用過之後立刻放棄的寫法，會拿出來講是因為：儘管被我棄用了，但在這個過程中也了解怎樣是不好的設計。為日後累積了些許的基石？enum AppFont { // 利用 Font size + 流水號，來為每個 case 命名 case style2401, style2402, style2403, style2001, style2002 var attributes: [NSAttributedString.Key: Any] { switch self { case .style2401: return createAttribute(weight: .regular, size: 24, color: .black, backgroundColor: .white, alignment: .left) case .style2402: return createAttribute(weight: .semibold, size: 24, color: .words, alignment: .right) // case ....}// 然後為每一個可以設置 Font 的 UIKit 元件寫一個方法去接收，並實際設置這些樣式設定這邊我曾經把用到的組合都用一個 enum 來包裝，然後利用 font size 來當作命名的開頭。曾經的我以為這樣很完美。但隨著案子的推進，樣式錯誤的時候，追蹤困難，許多樣式其實只是置左置右的差別，但卻多了一個 enum case。有極小的差異，但組合起來，數量很驚人。加上設計師有時候會調整或新增樣式時，這樣的寫法再新增及修改上極為困難，因此用了一段後時間立刻放棄。 不要試圖在一行 code 裡面包山包海。# Ready go接下來的這個時期，有兩個點同時給了我靈感 在 iOS@Taipei 時聽到了一位講者，在分享的時候介紹了一下他自製的套件 ChainsKit 。 在一個全新的案子中我開始使用 RxSwift 了。老實說在第一次看到 ChainsKit 之後，並沒有太多的感覺。但在我漸漸熟悉 RxSwift，並著迷於 RxSwift 之後，我發現 ChainsKit 是一種很棒寫法。那為什麼我沒有使用 ChainsKit 而是選擇打造一個自己的框架呢。因為很不巧的，在我使用從 SwifterSwift 學習到的一個 UIView 擴展: var borderColor 不小心與案子中另一個套件的命名衝突了。雖然我改用 xx_borderColor 這樣的命名來解決了這個問題。但底線式的命名方式實在很不符合個人的喜好…。接著再查詢 RxSwift 資料的時候，發現了一篇很棒的文章 [medium][https://medium.com/@DianQK/%E5%86%99%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84-swift-%E6%A1%86%E6%9E%B6-rx-tap-rx-tap-af0c417da3d6]，可以自訂一個 namespacing 的實作方法。總結了一下幾個點（用 Rx tap 舉例）： rx_Tap：一種反 swift 風格的風格 rxTap：符合 swift 風格的風格，但語意上容易造成困惑 reactiveTap：太冗長了以上幾點都還有兩個問題就是： 1. 為原本就很多的自動補全選項，又添上了許多選擇 2. 都只是換湯不換藥綜合以上種種原因，最終決定使用 rx.tap 這種方式 （其實只是用了別人的結論來實作）並且認真的實作成一個框架，而不是每次新案子都是整包檔案的拉來拉去。所以，OhSwifter 誕生啦！它用起來會像這樣 👇private let ohButton = UIButton().oh .title(&quot;Button Wording&quot;, for: .normal) .titleColor(.black, for: .normal) .titleColor(.gray, for: .normal) .cornerRadius(12) .border(color: .darkGray, width: 1) .done()這個框架解決了幾個問題： 以點鏈式的方式，將UI元件的宣告與樣式設置放在一起。 以返回 self 的方式，解決了 init closure 中重複輸入 label 的問題。 將 border color &amp;amp; width 放在同一個 fun 中，因為這兩個屬性幾乎是互相綁定的，諸如此類的還有陰影的設置。當然，在實作框架的時候發現，必須在宣告鏈的尾部使用 .base 來做解包的動作，看起來有點怪，不太符合語意，所以我加上了 .done() 方法來取出 base 的值。但本質上一樣是換湯不換藥；有點多餘，但目前沒有更好的想法了，好在整體而已，看起來還算順眼。好了，一個按照自己心意打造的框架，用起來就是舒服。儘管在不久的將來可能會因為種種原因，讓我棄用這個框架。 但這總歸是一個新開始。😁如果你有更好的想法，歡迎提出來一起討論。" }, { "title": "Swift 自訂轉場動畫，手勢(下)", "url": "/posts/swift-custom_transition_animation_2/", "categories": "animation", "tags": "animation, swift, transition", "date": "2019-03-31 00:00:00 +0800", "snippet": "Demo GIF這篇主要講手勢的使用，關於動畫實作的部分，在 上篇 有詳細的code接下來要在我們建立的 CustomTransition 裡面，跟系統說：我們的互動事件要透過誰來管理互動。class CustomTransition: NSObject, UIViewControllerTransitioningDelegate { // ... let interaction = UpToDownIneraction() func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -&amp;gt; UIViewControllerInteractiveTransitioning? { return nil } func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -&amp;gt; UIViewControllerInteractiveTransitioning? { print(interation.interacting) return interaction.interacting ? interaction : nil }}這邊使用 interaction.interacting ? interaction : nil 這樣的寫法，翻成中文大概的意思是：如果已經在處理互動了，那就不用多嘴跟系統說誰來處理互動。所以在 UpToDownIneraction 裡面我們宣告一個 interacting 來負責是否在互動中。注意這兩個 func 在 UIViewControllerTransitioningDelegate 裡面其實是 optional 的，如果不實做的話，系統會使用原生的手勢，ex: navigation 會有右滑返回的手勢。回傳 nil 同理。**那這邊只使用 interactionControllerForDismissal ，也就是 dismiss 需要的透過誰來管理。因為在出現的部分如果使用手勢，不熟悉的使用者可能會產生疑惑，除非UI上有明顯的提示，例如一個箭頭，加上一個抖動的動畫，不然使用點擊事件來當作出現的觸發條件會是比較好的選擇。接下來就是實作互動管理了先把 class 建立起來，並寫好我們需要的 propertyclass UpToDownIneraction: UIPercentDrivenInteractiveTransition { var interacting: Bool = false private var couldComplete: Bool = false private weak var presentingViewController: UIViewController? = nil}細心的人可能發現我們繼承的 class 是 UIPercentDrivenInteractiveTransition 而不上面 func 需要回傳的 UIViewControllerInteractiveTransitioning 這是蘋果提供的一個方便的類別，如果動畫中使用的是 UIView.animation，那我們就只需要告訴系統現在要 run 到第幾 % 。 interacting 是管理是否在互動中 couldComplete 負責的是，如果滑到一半，就放開手指，這時候是要跑完整個動畫，還是恢復動畫前的狀態。 presentingViewController 是我們需要加上手勢的 ViewController （除了配合手勢，執行動畫，還需要跟系統說我們要 dismiss 還是 pop，所以需要一個 property 存起來方便之後判斷） 然後實作我們需要的方法首先加上手勢，並做好手勢需要執行的空方法class UpToDownIneraction: UIPercentDrivenInteractiveTransition { // ... func wireGesture(on viewController: UIViewController) { presentingViewController = viewController let gesture = UIPanGestureRecognizer(target: self, action: #selector(handleGesture(_:))) viewController.view.addGestureRecognizer(gesture) } @objc func handleGesture(_ gestureRecoginizer: UIPanGestureRecognizer) { // ... }}接著實作手勢執行的方法， UIPercentDrivenInteractiveTransition 類別提供了我們幾個方法 update(_ percentComplete: CGFloat) cancel() finish()很明顯我們只需要算好手勢在畫面上移動的比例，然後使用 update 來更新，並在適當的時機跟系統說我們要 取消 或是 完成 動畫，即可。class UpToDownIneraction: UIPercentDrivenInteractiveTransition { // ... @objc func handleGesture(_ gestureRecoginizer: UIPanGestureRecognizer) { let gestureView = gestureRecoginizer.view! let trainsiton = gestureRecoginizer.translation(in: gestureView) switch gestureRecoginizer.state { case .began: print(&quot;began&quot;) interacting = true if let naviController = presentingViewController?.navigationController { naviController.popViewController(animated: true) } else { presentingViewController?.dismiss(animated: true, completion: nil) } case .changed: var fraction = trainsiton.y / gestureView.frame.height print(&quot;\\(fraction)&quot;) fraction = max(fraction, 0.0) fraction = min(fraction, 1) couldComplete = fraction &amp;gt; 0.4 update(fraction) case .cancelled, .ended: interacting = false if couldComplete == false || gestureRecoginizer.state == .cancelled { cancel() } else { finish() } default: break } }}484很簡單？這邊特別提醒一下，如果動畫不是使用 UIView.animation 來實作，那麽 UIPercentDrivenInteractiveTransition 就不適用了。這個坑害我搞了好久。萬事俱備只欠東風@objc func buttonPressed() { let vc = PresentSecondViewController() animation.destinationPoint = button.center vc.transitioningDelegate = animation vc.modalPresentationStyle = .custom animation.interaction.wireGesture(on: vc) present(vc, animated: true, completion: nil)}完整的範例在 Github" }, { "title": "Swift 自訂轉場動畫，手勢(上)", "url": "/posts/swift-custom_transition_animation/", "categories": "動畫", "tags": "animation, swift, transition", "date": "2019-03-10 00:00:00 +0800", "snippet": "Demo GIF本篇主要講述動畫的實作，手勢的部分留在下篇動畫的原理是使用 maskView 畫出一個圓，然後對圓進行放大縮小開始！首先我們先建立一個 class 用來管理我們 present &amp;amp; dismiss 的動畫要透過誰來動。class CustomTransition: NSObject, UIViewControllerTransitioningDelegate { // 擴散的中心點 var destinationPoint = CGPoint.zero private lazy var presentAnimation = CustomPresentAnimation(startPoint: destinationPoint) private lazy var dismissAnimation = CustomDismissAnimation(endPoint: destinationPoint) func animationController( forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController ) -&amp;gt; UIViewControllerAnimatedTransitioning? { return presentAnimation } func animationController(forDismissed dismissed: UIViewController) -&amp;gt; UIViewControllerAnimatedTransitioning? { return dismissAnimation }}點UIViewControllerTransitioningDelegate 進去看，可以發現裡面有五個 func 都是 optional，是這樣的，如果不實作，那系統將會使用原生的效果來顯示。我在網路上查的多數範例，是直接在 class CustomTransition 實作這個 protocol 然後 return self，但為了讓 code 看起來簡單一點，我選擇另外建立兩個 class confirm 這個 protocolPresentclass CustomPresentAnimation: NSObject , UIViewControllerAnimatedTransitioning { var startPoint: CGPoint // 擴散的起始點 private let durationTime = 0.45 // 動畫時間 init(startPoint: CGPoint) { self.startPoint = startPoint super.init() } func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&amp;gt; TimeInterval { return durationTime } func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { // ... }}接著我們在 func animateTransition 裡面實作我的們想要的動畫效果啦func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { // 取出 toView, 在上面的示意圖中代表的就是 A 畫面 guard let toView = transitionContext.viewController(forKey: .to)?.view else { return } // 取出 container view let containerView = transitionContext.containerView // 建立我們的 mask view，並坐初步設置 let maskView = UIView() maskView.frame.size = CGSize(width: 1, height: 1) maskView.center = startPoint maskView.backgroundColor = .black maskView.layer.cornerRadius = 0.5 toView.mask = maskView containerView.addSubview(toView) // 因為最終 mask view 的圓，需要覆蓋到整個畫面，所以計算出 mask view需要的大小 let containerFrame = containerView.frame let maxY = max(containerFrame.height - startPoint.y, startPoint.y) let maxX = max(containerFrame.width - startPoint.x, startPoint.x) let maxSize = max(maxY, maxX) * 2.1 // 最後我們使用 UIView.animation 顯式動畫，將我們的 mask view 擴散到整個畫面 UIView.animate( withDuration: durationTime, delay: 0, options: [.curveEaseOut], animations: { maskView.frame.size = CGSize(width: maxSize, height: maxSize) maskView.layer.cornerRadius = maxSize / 2.0 maskView.center = self.startPoint }) { flag in transitionContext.completeTransition(flag) } }反之，Dismiss 如下class CustomDismissAnimation: NSObject, UIViewControllerAnimatedTransitioning { let endPoint: CGPoint var grayView: UIView! private let durationTime = 0.45 init(endPoint: CGPoint) { self.endPoint = endPoint super.init() } func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&amp;gt; TimeInterval { return durationTime } func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { guard let fromView = transitionContext.viewController(forKey: .from)?.view else { return } let containerView = transitionContext.containerView let containerFrame = containerView.frame let maxY = max(containerFrame.height - endPoint.y, endPoint.y) let maxX = max(containerFrame.width - endPoint.x, endPoint.x) let maxSize = max(maxY, maxX) * 2.1 let maskView = UIView() maskView.frame.size = CGSize(width: maxSize, height: maxSize) maskView.center = endPoint maskView.backgroundColor = .black maskView.layer.cornerRadius = maxSize / 2.0 fromView.mask = maskView containerView.addSubview(fromView) UIView.animate( withDuration: durationTime, delay: 0, options: [.curveEaseOut], animations: { maskView.frame.size = CGSize(width: 1, height: 1) maskView.layer.cornerRadius = 0.5 maskView.center = self.endPoint }) { flag in transitionContext.completeTransition(!transitionContext.transitionWasCancelled) } }}萬事俱備，只欠東風東西都建立好啦，接著就是如何使用了 我們在Ａ畫面建立 CustomTransition，然後將Ｂ畫面的 transitioningDelegate 改為 CustomTransition， 並將 modalPresentationStyle 設置為 .customclass PrepareToPushViewController: UIViewController { let button = UIButton(type: .system) let animation = CustomTransition() override func viewDidLoad() { super.viewDidLoad() // set view layout } }}// MARK: Setup UI methodsextension PrepareToPushViewController { @objc func buttonPressed() { let vc = PresentSecondViewController() animation.destinationPoint = button.center vc.transitioningDelegate = animation vc.modalPresentationStyle = .custom animation.interation.wire(viewController: vc) present(vc, animated: true, completion: nil) }}" }, { "title": "Swift 數字處理大全", "url": "/posts/swift-number-detail/", "categories": "筆記", "tags": "swift, tip", "date": "2019-02-21 00:00:00 +0800", "snippet": "也可以到我的 Gist 看完整的 code 😄無條件進位 (小數，整數)整數的無條件進位ceil(11.2)// print 12// ceil 的意思是天花板無條件進位至 小數第x位extension Double { func ceiling(toDecimal decimal: Int) -&amp;gt; Double { let numberOfDigits = abs(pow(10.0, Double(decimal))) if self.sign == .minus { return Double(Int(self * numberOfDigits)) / numberOfDigits } else { return Double(ceil(self * numberOfDigits)) / numberOfDigits } }}123.12345.ceiling(toDecimal: 3)// print 123.124 (-123.12345).ceiling(toDecimal: 3)// print -123.123無條件進位至 整數第x位extension Double { func ceiling(toInteger integer: Int = 1) -&amp;gt; Double { let integer = integer - 1 let numberOfDigits = pow(10.0, Double(integer)) return Double(ceil(self / numberOfDigits)) * numberOfDigits }}123.12345.ceiling(toInteger: 2)// print 130.0(-123.12345).ceiling(toInteger: 2)// print -120.0四捨五入 (小數，整數)lround(11.2) -&amp;gt; Int// print 11round(11.5) -&amp;gt; Double// print 12.0四捨五入至 小數第x位extension Double { func rounding(toDecimal decimal: Int) -&amp;gt; Double { let numberOfDigits = pow(10.0, Double(decimal)) return (self * numberOfDigits).rounded(.toNearestOrAwayFromZero) / numberOfDigits }}24.141.rounding(toDecimal: 2)// 24.1424.145.rounding(toDecimal: 2)// 24.15(-24.141).rounding(toDecimal: 2)// -24.14(-24.145).rounding(toDecimal: 2)// -24.15四捨五入至 整數第x位extension Double { func rounding(toInteger integer: Int) -&amp;gt; Double { let integer = integer - 1 let numberOfDigits = pow(10.0, Double(integer)) return (self / numberOfDigits).rounded(.toNearestOrAwayFromZero) * numberOfDigits }}124.141.rounding(toInteger: 2)// 120.0 125.141.rounding(toInteger: 2)// 130.0 (-124.141).rounding(toInteger: 2)// -120.0 (-125.141).rounding(toInteger: 2)// -130.0無條件捨去 (小數，整數)Int(11.24)// print 11無條件捨去至 小數第x位extension Double { func floor(toDecimal decimal: Int) -&amp;gt; Double { let numberOfDigits = pow(10.0, Double(decimal)) return (self * numberOfDigits).rounded(.towardZero) / numberOfDigits }}124.141.floor(toDecimal: 2)// print 124.14(-124.141).floor(toDecimal: 2)// print -124.14無條件捨去至 整數第x位extension Double { func floor(toInteger integer: Int) -&amp;gt; Double { let integer = integer - 1 let numberOfDigits = pow(10.0, Double(integer)) return (self / numberOfDigits).rounded(.towardZero) * numberOfDigits }}124.141.floor(toInteger: 2)// print 120.0 (-124.141).floor(toInteger: 2)// print -120.0" } ]
